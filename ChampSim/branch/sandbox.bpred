#include "ooo_cpu.h"
#include "bp_candidates.h"

#include <fstream>
#include <sstream>

#define NUM_BUCKET 8

Predictor* basicBP[NUM_CPUS];
Predictor* complexBP[NUM_CPUS];

// variables to keep track of prediction history
uint64_t realHistory[NUM_CPUS][NUM_BUCKET];
uint64_t basicBPHistory[NUM_CPUS][NUM_BUCKET];
uint64_t complexBPHistory[NUM_CPUS][NUM_BUCKET];
bool predicted;
unsigned branchCount;

// Acciracies
int basicBPCorrect[NUM_CPUS][NUM_BUCKET];
int complexBPCorrect[NUM_CPUS][NUM_BUCKET];

// Prediction log files
const std::string fname = "branch.csv";
std::ofstream fout;

// helper functions
std::string int2hex(uint64_t pc);

/**
 * Increased upon mispredict, decreased over time.
 * Triggers a reset on the corresponding predictor when above certain threshold
 */
uint64_t reset_score[NUM_CPUS];

void O3_CPU::initialize_branch_predictor()
{
    cout << "CPU " << cpu << " Sandbox branch predictor" << endl;
    complexBP[cpu] = new Perceptron(7, 256, 8);
    complexBP[cpu]->reset();
    basicBP[cpu] = new Gshare(10, 2);
    basicBP[cpu]->reset();

    // initialize bookkeeping variables
    for (int i = 0; i < NUM_BUCKET; i++){
        realHistory[cpu][i] = 0;
        complexBPHistory[cpu][i] = 0;
        basicBPHistory[cpu][i] = 0;
    }
    reset_score[cpu] = 0;

    // Open log file
    fout.open(fname);
    fout << "ID, PC, Predicted, Actual" << std::endl;
    branchCount = 0;
}

/**
 * @brief Predict if the input branch instruction will be taken or not
 * 
 * @param instr The input branch instruction
 * @return true (1) if predicted taken, false (0) otherwise
 * 
 * TODO: Try more basic & complex predictor combinations
 * and update & reset policies
 */
uint8_t O3_CPU::predict_branch(ooo_model_instr instr)
{
    Prediction pred1 = basicBP[cpu]->predict(instr.ip);
    Prediction pred2 = complexBP[cpu]->predict(instr.ip);

    bool final_prediction;

    // Update prediction history
    basicBPHistory[cpu][instr.ip % NUM_BUCKET] = (basicBPHistory[cpu][instr.ip % NUM_BUCKET] << 1) | (pred1.taken ? 1 : 0);
    complexBPHistory[cpu][instr.ip % NUM_BUCKET] = (complexBPHistory[cpu][instr.ip % NUM_BUCKET] << 1) | (pred2.taken ? 1 : 0);
    // basicBPHistory[cpu] = (basicBPHistory[cpu] << 1) | (pred1.taken ? 1 : 0);
    // complexBPHistory[cpu] = (complexBPHistory[cpu] << 1) | (pred2.taken ? 1 : 0);

    // Make the final decision
    // final_prediction = (pred2.confidence > 5) ? pred2.taken : pred1.taken;
    final_prediction = (basicBPCorrect[cpu][instr.ip % 4] < complexBPCorrect[cpu][instr.ip % 4]) ? pred2.taken : pred1.taken;

    // Prepare for log generation
    predicted = final_prediction;

    return final_prediction;
}

/**
 * @brief Update the internal states of predictors
 * 
 * @param instr The branch instruction with known outcome
 */
void O3_CPU::last_branch_result(ooo_model_instr instr)
{
    complexBP[cpu]->update(instr.ip, instr.branch_taken);
    basicBP[cpu]->update(instr.ip, instr.branch_taken);

    // Update predictor scoreboard
    realHistory[cpu][instr.ip % NUM_BUCKET] = (realHistory[cpu][instr.ip % NUM_BUCKET] << 1) | (instr.branch_taken ? 1 : 0);
    reset_score[cpu] = (reset_score[cpu] * 3) >> 2; // multiply by 0.75

    // If prediction is wrong, update reset score
    if ((realHistory[cpu][instr.ip % NUM_BUCKET] & 1) != (complexBPHistory[cpu][instr.ip % NUM_BUCKET] & 1)){
        reset_score[cpu] += 16;
    } else { // If prediction is correst, update accuracy counts
        complexBPCorrect[cpu][instr.ip % NUM_BUCKET]++;
    }

    if ((realHistory[cpu][instr.ip % NUM_BUCKET] & 1) == (basicBPHistory[cpu][instr.ip % NUM_BUCKET] & 1)){
        basicBPCorrect[cpu][instr.ip % NUM_BUCKET]++;
    }

    // check reset condition
    // NOTE: Currently we are doing global reset using global history.
    // Maybe a local policy would perform better
    if (reset_score[cpu] > 2800) {
        reset_score[cpu] = 0;
        complexBP[cpu]->reset();
    }

    // write to log
    fout << branchCount++ << ", ";
    fout << int2hex(instr.ip) << ", ";
    fout << predicted << ", ";
    fout << (instr.branch_taken == 1 ? "1" : "0") << std::endl;
}

std::string int2hex(uint64_t pc) {
    std::stringstream sstream;
    sstream << std::hex << pc;
    return sstream.str();
}
